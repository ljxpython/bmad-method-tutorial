# 第八章：部署和监控

## 🎯 本章目标

学完本章后，你将：
- 🚀 掌握Brownfield项目的安全部署策略
- 📊 建立全面的生产监控体系
- 🔄 实现自动化运维和故障处理
- 📈 建立持续优化的运营机制

## 🚀 第一步：部署策略设计

### 1.1 蓝绿部署策略

#### 蓝绿部署实施
```yaml
# 蓝绿部署配置示例
apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: myapp
    version: blue  # 流量指向蓝环境
  ports:
  - port: 80
    targetPort: 8080

---
# 蓝环境（当前生产）
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      version: blue
  template:
    metadata:
      labels:
        app: myapp
        version: blue
    spec:
      containers:
      - name: app
        image: myapp:v1.0
        env:
        - name: NEW_FEATURE_ENABLED
          value: "false"

---
# 绿环境（新版本）
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      version: green
  template:
    metadata:
      labels:
        app: myapp
        version: green
    spec:
      containers:
      - name: app
        image: myapp:v2.0
        env:
        - name: NEW_FEATURE_ENABLED
          value: "true"
```

#### 流量切换脚本
```bash
#!/bin/bash
# 蓝绿部署切换脚本

DEPLOYMENT_TYPE=$1  # blue-to-green or green-to-blue
VERIFICATION_TIME=${2:-300}  # 验证时间，默认5分钟

function switch_traffic() {
    local target_version=$1
    echo "切换流量到 $target_version 环境"
    
    kubectl patch service app-service -p '{"spec":{"selector":{"version":"'$target_version'"}}}'
    
    echo "等待 $VERIFICATION_TIME 秒进行验证..."
    sleep $VERIFICATION_TIME
    
    # 验证新环境状态
    if verify_deployment $target_version; then
        echo "切换成功"
        cleanup_old_environment
    else
        echo "切换失败，执行回滚"
        rollback_traffic
    fi
}

function verify_deployment() {
    local version=$1
    
    # 检查健康状态
    health_check=$(curl -s http://app-service/health)
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    # 检查错误率
    error_rate=$(get_error_rate)
    if (( $(echo "$error_rate > 0.01" | bc -l) )); then
        return 1
    fi
    
    return 0
}

case $DEPLOYMENT_TYPE in
    "blue-to-green")
        switch_traffic "green"
        ;;
    "green-to-blue") 
        switch_traffic "blue"
        ;;
    *)
        echo "Usage: $0 {blue-to-green|green-to-blue} [verification_time]"
        exit 1
        ;;
esac
```

### 1.2 金丝雀部署策略

#### 渐进式流量切换
```yaml
# Istio金丝雀部署配置
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: app-canary
spec:
  hosts:
  - app-service
  http:
  - match:
    - headers:
        canary-user:
          exact: "true"
    route:
    - destination:
        host: app-service
        subset: v2
  - route:
    - destination:
        host: app-service
        subset: v1
      weight: 95
    - destination:
        host: app-service  
        subset: v2
      weight: 5  # 5%流量到新版本
```

## 📊 第二步：生产监控体系

### 2.1 四个黄金信号监控

#### 监控指标定义
```yaml
# Prometheus监控配置
monitoring_metrics:
  
  # 1. 延迟 (Latency)
  latency:
    - name: http_request_duration_seconds
      help: "HTTP请求延迟"
      buckets: [0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
    
    - name: database_query_duration_seconds  
      help: "数据库查询延迟"
      buckets: [0.01, 0.05, 0.1, 0.5, 1.0, 2.0]
  
  # 2. 流量 (Traffic)  
  traffic:
    - name: http_requests_total
      help: "HTTP请求总数"
      labels: [method, endpoint, status]
      
    - name: active_users_total
      help: "活跃用户数"
      
  # 3. 错误 (Errors)
  errors:
    - name: http_requests_errors_total
      help: "HTTP错误请求数"
      labels: [method, endpoint, error_type]
      
    - name: application_errors_total
      help: "应用程序错误总数"
      labels: [component, error_level]
  
  # 4. 饱和度 (Saturation)
  saturation:
    - name: system_cpu_usage_percent
      help: "CPU使用率"
      
    - name: system_memory_usage_percent  
      help: "内存使用率"
      
    - name: database_connection_pool_usage
      help: "数据库连接池使用率"
```

### 2.2 业务监控指标

#### 业务关键指标
```javascript
// 业务监控指标收集
const businessMetrics = {
  
  // 用户行为指标
  trackUserAction: (action, userId, metadata) => {
    prometheus.businessActionCounter.inc({
      action: action,
      user_type: getUserType(userId),
      feature: metadata.feature || 'unknown'
    });
  },
  
  // 功能使用指标
  trackFeatureUsage: (feature, userId, success) => {
    prometheus.featureUsageCounter.inc({
      feature: feature,
      success: success ? 'true' : 'false',
      user_cohort: getUserCohort(userId)
    });
  },
  
  // 业务转换指标
  trackConversion: (funnel, step, userId) => {
    prometheus.conversionFunnelCounter.inc({
      funnel: funnel,
      step: step,
      user_segment: getUserSegment(userId)
    });
  },
  
  // 收入相关指标
  trackRevenue: (amount, currency, source) => {
    prometheus.revenueGauge.set({
      currency: currency,
      source: source
    }, amount);
  }
};
```

### 2.3 告警规则配置

#### 分层告警策略
```yaml
# AlertManager告警规则
groups:
- name: brownfield-alerts
  rules:
  
  # P0 告警 - 立即响应
  - alert: ServiceDown
    expr: up{job="app-service"} == 0
    for: 1m
    severity: critical
    annotations:
      summary: "服务完全不可用"
      runbook: "https://wiki.company.com/runbooks/service-down"
    
  - alert: HighErrorRate
    expr: rate(http_requests_errors_total[5m]) > 0.1
    for: 2m  
    severity: critical
    annotations:
      summary: "错误率过高: {{ $value }}"
      
  # P1 告警 - 快速响应  
  - alert: HighLatency
    expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2.0
    for: 5m
    severity: warning
    annotations:
      summary: "响应时间过长: {{ $value }}s"
      
  - alert: DatabaseConnectionPoolHigh
    expr: database_connection_pool_usage > 0.8
    for: 10m
    severity: warning
    annotations:
      summary: "数据库连接池使用率过高"
      
  # P2 告警 - 标准响应
  - alert: HighResourceUsage
    expr: system_cpu_usage_percent > 80 OR system_memory_usage_percent > 85
    for: 15m
    severity: info
    annotations:
      summary: "系统资源使用率过高"
```

## 🔍 第三步：日志和追踪

### 3.1 结构化日志

#### 日志格式标准
```javascript
// 结构化日志示例
const logger = require('winston');

// 配置结构化日志格式
logger.configure({
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json(),
    winston.format.printf(({ timestamp, level, message, ...meta }) => {
      return JSON.stringify({
        timestamp,
        level,
        message,
        service: 'brownfield-app',
        version: process.env.APP_VERSION,
        correlation_id: meta.correlationId,
        user_id: meta.userId,
        feature: meta.feature,
        metadata: meta
      });
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ 
      filename: '/var/log/app/application.log',
      maxsize: 100 * 1024 * 1024, // 100MB
      maxFiles: 10
    })
  ]
});

// 使用示例
function processUserRequest(req, res) {
  const correlationId = req.headers['x-correlation-id'] || generateId();
  
  logger.info('Processing user request', {
    correlationId,
    userId: req.user?.id,
    feature: 'new_feature',
    endpoint: req.path,
    method: req.method
  });
  
  try {
    const result = processRequest(req);
    
    logger.info('Request processed successfully', {
      correlationId,
      userId: req.user?.id,
      feature: 'new_feature',
      duration: Date.now() - req.startTime
    });
    
    res.json(result);
  } catch (error) {
    logger.error('Request processing failed', {
      correlationId,
      userId: req.user?.id, 
      feature: 'new_feature',
      error: error.message,
      stack: error.stack
    });
    
    res.status(500).json({ error: 'Internal server error' });
  }
}
```

### 3.2 分布式追踪

#### OpenTelemetry集成
```javascript
// OpenTelemetry配置
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { Resource } = require('@opentelemetry/semantic-conventions');

const sdk = new NodeSDK({
  resource: Resource.default().merge(
    new Resource({
      'service.name': 'brownfield-app',
      'service.version': process.env.APP_VERSION,
    }),
  ),
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-fs': {
        enabled: false,
      },
    }),
  ],
});

sdk.start();

// 自定义span示例
const opentelemetry = require('@opentelemetry/api');

function processNewFeature(userId, data) {
  const tracer = opentelemetry.trace.getTracer('brownfield-app');
  
  return tracer.startActiveSpan('process_new_feature', (span) => {
    span.setAttributes({
      'user.id': userId,
      'feature.name': 'new_feature',
      'data.size': JSON.stringify(data).length
    });
    
    try {
      // 处理新功能逻辑
      const result = handleNewFeatureLogic(data);
      
      span.setStatus({ code: opentelemetry.SpanStatusCode.OK });
      span.setAttributes({
        'result.success': true,
        'result.items_processed': result.length
      });
      
      return result;
    } catch (error) {
      span.setStatus({ 
        code: opentelemetry.SpanStatusCode.ERROR,
        message: error.message 
      });
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  });
}
```

## 🔧 第四步：自动化运维

### 4.1 自愈机制

#### 自动恢复脚本
```bash
#!/bin/bash
# 服务自愈脚本

SERVICE_NAME="brownfield-app"
HEALTH_ENDPOINT="http://localhost:8080/health"
MAX_RESTART_COUNT=3
RESTART_COUNT_FILE="/var/log/${SERVICE_NAME}_restart_count"

function check_service_health() {
    local response_code=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_ENDPOINT)
    
    if [[ $response_code == "200" ]]; then
        return 0
    else
        return 1
    fi
}

function restart_service() {
    local current_count=$(cat $RESTART_COUNT_FILE 2>/dev/null || echo "0")
    
    if [[ $current_count -ge $MAX_RESTART_COUNT ]]; then
        echo "达到最大重启次数，需要人工干预"
        send_alert "Service $SERVICE_NAME failed multiple times, manual intervention required"
        return 1
    fi
    
    echo "重启服务 $SERVICE_NAME (第 $((current_count + 1)) 次)"
    systemctl restart $SERVICE_NAME
    
    echo $((current_count + 1)) > $RESTART_COUNT_FILE
    
    # 等待服务启动
    sleep 30
    
    if check_service_health; then
        echo "服务重启成功"
        rm -f $RESTART_COUNT_FILE  # 重置计数器
        return 0
    else
        echo "服务重启后仍然不健康"
        return 1
    fi
}

function send_alert() {
    local message=$1
    # 发送告警到Slack/钉钉等
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"$message\"}" \
        $WEBHOOK_URL
}

# 主逻辑
if ! check_service_health; then
    echo "检测到服务不健康，尝试重启"
    if ! restart_service; then
        echo "自动恢复失败，发送告警"
        send_alert "Failed to automatically recover $SERVICE_NAME"
        exit 1
    fi
else
    echo "服务健康正常"
    # 清理重启计数器
    rm -f $RESTART_COUNT_FILE
fi
```

### 4.2 容量自动扩缩容

#### HPA配置
```yaml
# 水平Pod自动扩缩容
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: brownfield-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: brownfield-app
  minReplicas: 2
  maxReplicas: 20
  metrics:
  
  # CPU使用率
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
        
  # 内存使用率      
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
        
  # 自定义指标 - 请求队列长度
  - type: Pods
    pods:
      metric:
        name: request_queue_length
      target:
        type: AverageValue
        averageValue: "30"
        
  # 扩缩容行为配置
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
```

## 📈 第五步：性能优化

### 5.1 性能基准测试

#### 负载测试配置
```yaml
# K6负载测试脚本
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 },   // 预热阶段
    { duration: '5m', target: 100 },   // 稳定负载
    { duration: '2m', target: 200 },   // 增加负载
    { duration: '5m', target: 200 },   // 高负载稳定
    { duration: '2m', target: 500 },   // 压力测试
    { duration: '5m', target: 500 },   // 压力稳定
    { duration: '2m', target: 0 },     // 降负载
  ],
  thresholds: {
    'http_req_duration': ['p(95)<2000'],  // 95%请求<2s
    'http_req_failed': ['rate<0.01'],     // 错误率<1%
  },
};

export default function() {
  // 测试现有功能
  let legacyResponse = http.get('http://api.example.com/v1/users/me');
  check(legacyResponse, {
    'legacy API status is 200': (r) => r.status === 200,
    'legacy API response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  // 测试新功能  
  let newResponse = http.get('http://api.example.com/v2/users/me/enhanced');
  check(newResponse, {
    'new API status is 200': (r) => r.status === 200,
    'new API response time < 1000ms': (r) => r.timings.duration < 1000,
  });
  
  sleep(1);
}
```

### 5.2 性能监控和优化

#### 性能监控仪表板
```json
{
  "dashboard": {
    "title": "Brownfield Performance Dashboard",
    "panels": [
      {
        "title": "Response Time Comparison",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{endpoint=~\"/api/v1/.*\"}[5m]))",
            "legendFormat": "Legacy API P95"
          },
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{endpoint=~\"/api/v2/.*\"}[5m]))",
            "legendFormat": "New API P95"
          }
        ]
      },
      {
        "title": "Throughput Comparison", 
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total{endpoint=~\"/api/v1/.*\"}[5m])",
            "legendFormat": "Legacy API RPS"
          },
          {
            "expr": "rate(http_requests_total{endpoint=~\"/api/v2/.*\"}[5m])",  
            "legendFormat": "New API RPS"
          }
        ]
      }
    ]
  }
}
```

## ✅ 完成检查

完成本章实践后，你应该建立：

### 部署体系
- [ ] 蓝绿/金丝雀部署策略
- [ ] 自动化部署流水线
- [ ] 回滚和应急机制
- [ ] 环境一致性保证

### 监控体系  
- [ ] 四个黄金信号监控
- [ ] 业务指标监控
- [ ] 分层告警配置
- [ ] 性能基准测试

### 运维体系
- [ ] 结构化日志收集
- [ ] 分布式链路追踪
- [ ] 服务自愈机制
- [ ] 容量自动管理

### 优化体系
- [ ] 性能监控仪表板
- [ ] 持续性能优化
- [ ] 容量规划预测
- [ ] 成本效益分析

## 🎉 Brownfield项目完成

恭喜！你已经完成了BMAD-METHOD Brownfield项目的完整学习和实践。

### 项目成果总结
- ✅ 完整的项目分析和文档
- ✅ 系统化的功能规划和设计  
- ✅ 渐进式的开发和集成
- ✅ 全面的风险管理和测试
- ✅ 生产级的部署和监控

### 下一步建议
1. **应用到实际项目**: 将学到的方法应用到工作项目中
2. **团队分享**: 向团队分享BMAD-METHOD的价值
3. **持续改进**: 基于实践经验持续优化流程
4. **社区贡献**: 向BMAD-METHOD社区分享经验

**[查看案例研究 →](案例研究/)**

---

*🎊 恭喜完成Brownfield教程！现在你已经掌握了在现有项目中使用BMAD-METHOD的完整技能。这些知识将帮助你在实际工作中更加自信和高效地改进现有系统。*